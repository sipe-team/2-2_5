# 10장 - 이름 설계: 구조를 파악할 수 있는 이름

## 10.1. 악마를 불러들이는 이름

### 배경

- 온라인 쇼핑몰은 상품을 중심으로 이루어짐 (출고 예약, 주문, 발송 등)
→ 개발자는 클래스 이름을 ‘상품’이라고 명명

### 문제 상황

- 이름을 단순하게 ‘상품’이라고 명명하면 여러 유스케이스와 관계를 맺게 됨, 강한 결합 구조인 상태
- 너무 포괄적이고 의미가 불분명함 (=목적 불명 객체)
- 용이한 수정을 위해 결합이 느슨하고 응집도가 높은 구조로 만들 필요가 있음

### 해결법

목적 중심 이름 설계하면 됨. 뭔지는 2절에서 자세히 다룬다.

**1) 관심사 분리**

- 관심사 분리: ‘관심사(유스케이스, 목적, 역할)에 따라서 분리한다’라는 소프트웨어 공학의 개념
- 상품 클래스를 관심사에 따라서 각각 클래스로 분할

**2) 관심사에 맞는 이름 붙이기**

- 모든 클래스에 ‘상품’이라는 이름을 붙일 수는 없다 (포괄적이고 의미가 불분명)
- 비즈니스 목적에 따라 이름을 붙이자: 상품 → 주문 상품, 예약 상품, 재고 상품, 발송 상품으로 변경
= 어떤 기능이 있는지 생각해보자

## 10.2. 이름 설계하기 - 목적 중심 이름 설계

목적 중심 이름 설계: 소프트웨어로 달성하고 싶은 목적과 의도를 이름만으로도 알 수 있게 하는 것

### 목적 중심 이름 설계 방법

**1) 최대한 구체적이고, 의미 범위가 좁고, 특화된 이름 선택하기**

‘회사가 사업적으로 어떤 목적을 달성하고 싶은가?’하는 비즈니스 목적에 따라 의미 범위가 좁은 이름을 클래스에 붙이기. 

- e.g., 1절에서 설명한 ‘상품’ → ‘주문 상품’, ‘예약 상품’, ‘재고 상품’, ‘발송 상품’.
- 장점
    - 이름과 관계없는 로직을 배제하기 쉬워짐
    - 클래스가 작아짐
    - 관계된 클래스 개수가 적으므로, 결합도가 낮아짐
    - 관계된 클래스 개수가 적으므로, 사양 변경 시 생각해야 하는 영향 범위가 좁음
    - 목적에 특화된 이름을 갖고 있으므로, 어떤 부분을 변경해야 할 때 쉽게 찾을 수 있음
    - 개발 생산성이 향상됨

**2) 존재가 아니라 목적을 기반으로 하는 이름 생각하기**

- 존재 기반 이름: 단순하게 존재하기 때문에 붙인 이름
    - e.g., ‘주소’, ‘금액’, ‘사용자’ 등
    - 너무 포괄적, 로직이 복잡해질 수 있음
- 목적 기반 이름: 구체적인 목적을 나타내는 이름
    
    
    | 존재 기반 | 목적 기반 |
    | --- | --- |
    | 주소 | 발송지, 배송지, 업무지 |
    | 금액 | 청구 금액, 소비세액, 연체 보증료, 캠페인 할인 금액 |
    | 사용자 | 계정, 개인 프로필, 직무 |
    | 사용자 이름 | 계정 이름, 닉네임(별칭), 본명, 법인명 |
    | 상품 | 입고 상품, 예약 상품, 주문 상품, 발송 상품 |

**3) 어떤 비즈니스 목적이 있는지 분석하기**

- 소프트웨어가 추구하는 목적과 내용을 분석해야 함
- 등장 인물과 관련 내용을 나열해보고, 관계를 정리하고 분석
    
    
    | 소프트웨어 | 목적/내용 |
    | --- | --- |
    | 온라인 쇼핑몰 | 판매 제품, 주문, 발송, 캠페인 |
    | 게임 | 무기, 아이템, 몬스터, 기간 이벤트 |
    | sns | 메시지, 팔로워, 타임라인 |

**4) 소리 내어 이야기해 보기**

- 고무 오리 디버깅: 프로그래밍에서 어떤 문제가 발생했을 때, 문제 누군가에게 설명하다 보면 스스로 원인을 깨닫고 해결할 수 있다는 방법
- 유비쿼터스 언어: 팀 전체에서 의도를 공유하기 위한 언어
→ 다른 사람들과 의논해보라는 소리

**5) 이용 약관 읽어 보기**

- 이용 약관에는 서비스와 관련된 규칙이 엄격한 표현으로 작성되어 있어 비즈니스 관련 명확한 이름을 알 수 있음
- 비즈니스 규칙과 클래스를 일치하게 만들면 정확하고 빠르게 변경 가능
- 우리 회사 이용 약관을 읽어보자.
    
    > **제22조 (대금결제)**
    ① 콘텐츠에 대한 구매 대금의 부과와 납부는 원칙적으로 결제대행사나 오픈마켓 사업자 등에서 정하는 정책이나 방법에 따릅니다. 또한 각 결제수단별 한도는 회사나 결제대행사 또는 오픈마켓 사업자가 정하는 정책 또는 정부의 방침에 따라 부여되거나 조정될 수 있습니다.
    ② 콘텐츠의 구매대금을 외화로 결제하는 경우에는 환율ㆍ수수료 등으로 인하여 실제 청구금액이 서비스의 상점 등에서 표시된 가격과 달라질 수 있습니다.
    > 
    
    ~~어.. 책에선 수수료 같은 거 어떤 식으로 계산되는지 친절히 설명해주던데~~
    

**6) 다른 이름으로 대체할 수 없는지 검토하기**

- 열심히 이름을 정해도 이상할 수 있으니 다른 이름으로 바꿔 보고, 개선할 수 있는지 검토하자.
- e.g., 호텔 숙박 예약 시스템의 시스템 사용자를 뭐라고 지을까?
    - ‘사용자’ → 의미 범위가 너무 넓음, 시스템 관리자도 있으니까
    - ‘고객’ → 숙박하는 사람과 결제하는 사람이 다를 수 있음
    
    → ‘투숙객’, ‘결제자’로 명명
    

**7) 결합이 느슨하고 응집도가 높은 구조인지 검토하기**

- 목적 이외의 로직이 섞였는지 확인할 것. 섞였다면 이름을 잘못 붙였는지 검토해볼 것.
- 다른 클래스 몇 개와 관련되어 있는지 개수를 확인할 것. 관련이 많다면 분해할 것.

## 10.3. 이름 설계 시 주의 사항

**1) 이름에 관심 갖기**

- 목적 중심 이름 설계는 이름에 주의를 기울이고 이름과 로직을 대응시킨다는 전제, 관심을 갖자

**2) 사양 변경 시 ‘의미 범위 변경’ 경계하기**

- 개발 중에 사양 변경이 자주 발생하니 중간중간 다시 검토해라

**3) 대화에는 등장하지만 코드에 등장하지 않는 이름 주의하기**

- e.g., ‘문제가 있는 회원’을 구현해야 한다. 이미 구현했다고 해서 소스코드를 보니 그런 내용이 안 보인다. 알고 보니까 조건을 만족하면 User를 문제가 있는 회원으로 구분하도록 구현했다.
- 이렇게 되면 로직 이해하기 힘들고 관련 사양이 변경됐을 때 찾기도 힘듦.
- 대화에서 많이 등장한다 싶으면 그 이름 기반으로 메서드와 클래스 설계를 고려해라.

**4) 수식어를 붙여서 구별해야 하는 경우는 클래스로 만들어 보기**

- 수식어를 붙여서까지 차이를 나타내고 싶으면 각각을 클래스로 설계할 수 없는지 검토하자.
- 헷갈리는 로직을 동료에게 물어볼 때 동료가 사용하는 수식어에 주의하면 도움 됨
    - e.g., 이 플래그가 true인 User는 문제가 있는 회원이다 → 일반 회원, 문제 있는 회원 클래스화
    - e.g., 이 줄에 있는 price는 새 제품 가격이고, 다음 줄에 있는 price는 중고 제품 가격이다 → 새 제품, 중고 제품 클래스화

## 10.4. 의미를 알 수 없는 이름

**1) 기술 중심 명명**

- 기술 중심 명명: 기술을 기반으로 이름 짓는 방법
- 소프트웨어를 구현하는 방법이지 비즈니스 목적을 나타내는 이름에는 적합하지 않음

| 종류 | 예 |
| --- | --- |
| 컴퓨터 기술 유래 | memory, cache, thread, register |
| 프로그래밍 기술 유래 | function, method, class, module |
| 자료형 이름 유래 | int, str, flag |

**2) 로직 구조를 나타내는 이름**

- e.g., 멤버가 마법을 사용할 수 있는 상태인지 판정하는 로직
    - 조건: 히트포인트가 0보다 큰가? 행동 가능한가? 매직포인트가 남아있는가?
    - isMemberHpMoreThanZeroAndIsMemberCanActAndIsMemberMpMoreThanMagicCostMp → canEnchant

**3) 놀람 최소화 원칙**

- 놀람 최소화 원칙: 사용자가 예상하지 못한 놀라움을 최소화하도록 설계해야 한다는 접근 방법

```python
class Order:
	def __init__(self, id: OrderId, items: Items, gift_point: GiftPoint):
		self.id = id
		self.items = items
		self.gift_point = giftPoint
	
	def item_count(self):
		count = self.items.count()
		
		if 10 <= count:
			self.gift_point = self.gift_point.add(GiftPoint(100))
			
		return count
```

- int count = order.item_count()를 했을 때, 주문 상품 수만 리턴한다고 생각하겠지만, 실제로 기프트 포인트까지 추가하고 있다면? 놀람놀람.

```python
class Order:
	def __init__(self, id: OrderId, items: Items, gift_point: GiftPoint):
		self.id = id
		self.items = items
		self.gift_point = gift_point
	
	def item_count(self):
		return items.count
	
	def should_add_gift_point(self):
		return 10 <= self.item_count()
	
	def try_add_gift_point(self):
		if self.shoud_add_gift_point():
			self.gift_point = self.gift_point.add(GiftPoint(100))
```

- 이렇게 메서드를 나누면 안 놀람

## 10.5. 구조에 악영향을 미치는 이름

**1) 데이터 클래스처럼 보이는 이름**

- e.g., ~Info, ~Data: 데이터 클래스 같이 보임. 데이터 클래스는 악마를 불러온다고 계속 말해왔음.
ProductInfo → Product로 하고 관련 로직을 같이 캡슐화
- 예외로 데이터 전송 용도로 사용되는 DTO는 데이터 클래스여도 됨 (단, 값 변경 x)

**2) 클래스를 거대하게 만드는 이름**

- e.g., Manager, Processor, Controller
    - 게임 개발 초기 파티 멤버를 일괄 관리하는 MemberManager 만듦
    → 멤버 히트 포인트 추출, 멤버 매직 포인트 추출 기능 구현했음.
    - 이후 보행 애니메이션 구현. 
    → 멤버 보행 애니메이션 처리 추가
    - 이후 모든 속성을 csv형식으로 내보내는 메서드, 적이 생존해 있는지 확인하는 기능, BGM 재생 등 모든 걸 구현하게 됨
    
    Manager는 너무 범위가 넓다! 이렇게 되면 결과적으로 단일 책임 원칙 위반. 
    
    해결책은 역시 목적 중심 이름 설계. 히트 포인트는 HitPoint 클래스가, 보행 애니메이션은 WalkAnimation이 처리하게끔 해야 됨
    

**3) 상황에 따라 의미가 달라질 수 있는 이름**

문제: 상황(컨텍스트)이 달라지면 자동차와 관련된 개념이 서로 반대가 됨

해결법: 어떤 컨텍스트가 둘러싸고 있는지 분석하고 각 컨텍스트별로 클래스를 설계

- e.g., 자동차를 다루는 서비스
    - 배송 컨텍스트: 자동차가 화물로 배송되는 컨텍스트, 자동차는 발송지, 배송지, 배송 경로와 관련
    - 판매 컨텍스트: 딜러에 의해 고객에게 판매되는 컨텍스트, 자동차는 판매 가격, 판매 옵션 등에 관련
    - 모든 걸 Car 클래스에 구현하면 여러 컨텍스트의 로직을 가져 거대해짐
    → 각 컨텍스트를 서로 다른 패키지로 선언, 그리고 각 패키지에 서로 다른 Car 클래스를 구현

**4) 일련번호 명명**

일련번호 명명: 클래스와 메서드의 이름에 번호를 붙여 만드는 것. 

e.g., Class001, method001

이러면 질서를 유지하기 위해 기능을 추가할 때 기존의 메서드에 로직을 추가할 가능성 높음. 쓰지 마라.

## 10.6. 이름을 봤을 때, 위치가 부자연스러운 클래스

**1) ‘동사 + 목적어’ 형태의 메서드 이름 주의하기**

‘동사 + 목적어’로 이루어진 이름은 관계없는 책무를 가진 메서드일 가능성이 존재

- e.g., 게임에서 적을 나타내는 Enemy 클래스
    - 도망치기: escape
    - 매직포인트 소비: consumeMagicPoint
    - 주인공 파티에 아이템 추가: addItemToParty
    - Enemy클래스의 관심사는 적인데, 주인공 파티에 아이템 추가는 주인공 소지품을 다루는 거.
    - 이렇게 관심사가 다르면 addItemToParty처럼 동사+목적어 형태가 되는 경향이 있음

**2) 가능하면 메서드의 이름은 동사 하나로 구성되게 하기**

- 문제: 동사 + 목적어 형태의 메서드
- 해결법
    - 목적어의 개념을 나타내는 클래스를 따로 구현
    - 그 클래스에 동사 하나 형태의 메서드 구현
    - e.g., addItemToParty → PartyItems 클래스 구현, 내부에 add 메서드 구현

**3) 부적절한 위치에 있는 boolean 메서드**

- boolean을 리턴하는 메서드는 is~, has~, can~ 형태의 이름이 붙는 경우가 다수
- `‘클래스 is/has/can 상태’`로 읽어봤을 때 자연스러운 영어 문장이 되는지 확인하기.
- e.g., Common클래스에 isMemberInConfusion은 적절한가?

```python
# 예시, Member 클래스의 isHungry 메서드는? 자연스럽다
The member is hungry

# Common클래스의 isMemberInConfusion 메서드는? 부자연스럽다
Common is member in confusion

# Member 클래스가 주어가 되도록 변경, 자연스럽다!
Member is in confusion

# -> 따라서 멤버가 혼란 상태인지 확인하는 메서드는 Member 클래스에 정의하는 것이 좋다.
```

## 10.7. 이름 축약

**1) 의도를 알 수 없는 축약**

귀찮아도 그냥 다 써라

```python
int trFee = brFee + LRF * dod;
int totalRentFee = basicRentalFee + LATE_RENTAL_FEE_PER_DAY * daysOverdue;
```

**2) 기본적으로 이름은 축약하지 말기**

- 예외: VIP, SNS

**3) 이름을 축약할 수 있는 경우**

- 반복문에 i, j 말고는 웬만하면 하지 마라.
