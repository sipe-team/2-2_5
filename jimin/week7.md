## 8.1 결합도와 책무

**단일 책임 원칙**: 클래스가 담당하는 책임은 하나로 제한

* 단일 책임 원칙을 지키지 않으면 여러 코드 중복, 결합된 클래스의 사이드 이펙트 등 문제가 발생할 수 있다.
* 같은 로직, 비슷한 로직이라도 개념이 다르면 중복을 허용할 필요가 있다.


## 8.2 다양한 강한 결합 사례와 대처 방법

### 상속과 관련된 강한 결합

**1) 슈퍼 클래스 의존**

상속은 주의해서 다루지 않으면 곧바로 **강한 결합 구조**를 유발하는 문법이다. 
오버라이드로 인해 의도와 다르게 동작할 수 있다.

**2) 상속보다 컴포지션**

슈퍼 클래스 의존으로 인한 강한 결합을 피하려면, 인스턴스 변수로 갖고 사용하는 컴포지션을 사용하면 된다.

**3) 상속을 사용하는 나쁜 일반화**

상속을 사용하면 슈퍼 클래스가 공통 로직을 두는 장소로 사용되는데, 상속을 무리하게 일반화하게 된다면 강한 결합이 발생하기 쉽다.

-> 상속은 단일 책임 원칙을 염두에 두고 구현하도록 하고, **값 객체와 컴포지션 등 다른 설계**를 사용할 수 없는지 검토가 필요하다.

### 인스턴스 변수별로 클래스 분할이 가능한 로직
'각 메서드가 어떤 인스턴스 변수를 활용하고 있는가' 를 살펴본 후, 클래스를 분할하도록 해보자

### 특별한 이유 없이 public 사용하지 않기
관계를 맺지 않았으면 하는 클래스끼리도 결합되어, 영향 범위가 확대된다. 패키지는 밀접한 클래스끼리 응집하게 설계하므로, 패키지들의 불필요한 의존 관계를 피할 때 `package private` 이 적잘하다.

### private 메서드가 너무 많다는 것은 책임이 너무 많다는 것 
책임이 다른 메서드는 다른 클래스로 분리하는 것이 좋다.

### 높은 응집도를 오해해서 생기는 강한 결합
* **높은 응집도**: 관련이 깊은 데이터와 논리를 한곳에 모은 구조

**응집도가 높다는 개념을 염두에 두고** 관련이 깊다고 생각되는 로직을 한곳에 모으려고 한다면, 결과적으로 **강한 결합 구조**를 만드는 상황은 매우 잦다. 

-> 각각의 개념을 **클래스에 잘 분할해서 값 객체**로 설계하는 것이 좋다. 

### 스마트 UI 
* 스마트 UI: 화면 표시를 담당하는 클래스에서 로직이 구현되어 있는 것

로직과 화면 그리는 건 분리하도록 하자.

### 거대 데이터 클래스
* 거대 데이터 클래스: 수많은 인스턴스 변수를 가짐
다양한 데이터를 가지므로, 수많은 유스케이스에서 사용되고 결국 전역 변수와 같은 성질을 띠게 된다.

### 트랜잭션 스크립트 패턴
* 트랜잭션 스크립트 패턴: 메서드 내부에 일련의 처리가 **길게 작성**되어 있는 구조

데이터를 보유하고 있는 클래스와 데이터를 처리하는 클래스를 나누어 구현할 때 자주 발생하는 형태이다. 응집도는 낮아지고 결합은 강해지므로 변경하기 어려워진다.

### 갓 클래스
* 갓 클래스: 하나의 클래스 내부에서 수만 줄의 로직을 가지고 있고, 로직이 난잡하게 섞여 있는 클래스

원인 추적이 힘드므로 클래스 하나에 모든 로직을 넣지 말자

### 강한 결합 클래스 대처 방법
책임별로 클래스를 분할해야 한다. 단일 책임 원칙에 따라 설계된 클래스는 아무리 많아도 200줄, 일반적으론 100줄 정도다..!

