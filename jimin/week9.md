## 10.1 악마를 불러들이는 이름

여러 유스케이스와 관계를 맺게 될만한 이름을 짓지말자. 여러 클래스와 관련 있는 로직을 갖게 되고, 클래스가 거대해져 **강한 결합 구조**가 되어버린다. 

* 관심사 분리(유스케이스, 목적, 역할에 따라 분리) 필요
* 포괄적인 이름을 가지는 목적 불명 객체 지양 
	* 상품 -> 예약상품, 주문상품, 재고상품 등등 비즈니스 목적에 따라 이름 붙여보기

## 10.2 이름 설계하기 - 목적 중심 이름 설계

* 최대한 구체적이고, 의미 범위가 좁고, 특화된 이름 선택
* 존재가 아니라 목적을 기반으로 하는 이름 생각
	* ex) 온라인 쇼핑몰에서의 주소는 배송 목적이므로 배송지와 같이 목적에 특화되도록 짓기
* 유비쿼터스 언어
	* 같은 의도를 갖고 이름을 대화, 문서, 클래스 이름, 메서드 이름에 활용 
	* 계속에서 이름을 다듬어나가는 것이 중요 
* 이용 약관 읽어 보기
	* 이용 약관에서 비즈니스와 관련된 이름을 알 수 있음
* 다른 이름으로 대체할 수 없는지 검토
	* ex) 숙박앱에서 고객을 투숙객, 결제자처럼 상세하게 나눌 수 있음
* 결합이 느슨하고 응집도가 높은 구조인지 검토
	* 목적에 특화된 이름을 선택하면 목적 이외의 로직을 배제하기 쉬워짐, 만약 목적 이외의 로직이 섞인다면 이름을 잘못 붙인 것은 아닌지 검토 필요
	* 관련된 클래스 개수 확인 필요, 적을수록 영향 범위 줄어듬

## 10.3 이름 설계 시 주의 사항
* 이름과 로직이 대응된다는 전제 필요
* 사양 변경 시, 개발 맥락에서 말이 의미하는 바가 점점 변화하는 경우가 있기에 이름 설계는 중간중간 검토 필요
* 대화에는 등장하지만 코드에 등장하지 않는 이름 주의
* 수식어를 붙여서 구별해야 하는 경우는 클래스로 만들어 보기
	* ex) 캐릭터의 원래 최대 히트포인트, 장비 착용으로 높아진 최대 히트포인트 와 같이 수식어가 붙는다면 클래스로 정의할 수 있다. 

## 10.4 의미를 알 수 없는 이름
 `tmp` 와 같이 임시 저장을 위해 의미 알 수 없이 짓는 경우가 있는데, 이는 매번 해석이 필요하므로 개발 속도를 낮출 수 있다.

의미가 분명하지 않은 이름이 되기 쉬운 경우는 다음과 같다.
* 기술 중심 명명
	* memory, flag 등 기술 용어는 비즈니스 목적을 나타내는 이름에 적합하지 않음
* 로직 구조를 나타내는 이름
	* 말 그대로 `isMoreThan ~~`보다 `canEnchant`처럼 목적을 지어보자
* 놀람 최소화 원칙
	* 메서드만 봤을때 예상되는 행위만 하자

## 10.5 구조에 악영향을 미치는 이름

이름이 클래스 구조에 악영향을 미칠 수 있다.

1. 데이터 클래스처럼 보이는 이름
	* `Info`, `Data` 와 같은 클래스는 데이터만 갖는 클래스로, 로직을 구현하면 안된다는 인식을 심어줄 수 있다.
	* dto 는 예외
2. 클래스를 거대하게 만드는 이름
	* `Manager`와 같이 여러 책무를 떠안기 쉬운 네이밍은 지양하자 (`Processor`, `Controller`도 마찬가지)
	* 책무가 다른 로직은 다른 클래스로 정의하자 
3. 상황에 따라 의미가 달라질 수 있는 이름
	* 컨텍스트가 다른데 하나의 클래스에 모든 것을 구현하면, 여러 컨텍스트의 로직을 갖게 된다. 
	* 각 컨텍스트는 서로 다른 패키지로 선언하자.
4. 일련번호 명명

## 10.6 이름을 봤을 때, 위치가 부자연스러운 클래스 
* 동사 + 목적어 형태의 메서드 이름 주의
	* 관계없는 책무를 가진 메서드일 가능성이 있다. 
	* -> 가능하면 메서드의 이름은 동사 하나로 구성되게 하자
* 부적절한 위치에 있는 boolean 메서드
	* `is`, `has`, `can` 형태의 이름이 붙는 경우가 많은데, `클래스 is 상태` 와 같이 영어로 생각했을 때 위화감이 없으면 좋다. 

## 10.7 이름 축약
* 기본적으로 이름은 축약하지 말자
* 이름을 축약할 수 있는 경우
	* 의미가 사라지지 않는지, 추가적인 다른 문제가 발생하지 않는지 확인 필요
	* ex) 카운터 변수 i,j 처럼 범위 작고 의미가 헷갈릴 여지가 적으면 축약 가능 