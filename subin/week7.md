# 8장 강한 결합 : 복잡하게 얽혀서 풀 수 없는 구조

**결합도**란 '모듈 사이의 의존도를 나타내는 지표' 또는 '클래스 사이의 의존도를 나타내는 지표'라고도 할 수 있습니다.

- 강한 결합
  - 어떤 클래스가 다른 클래스에 많이 의존하고 있는 구조
  - 코드를 이해하기 어렵고, 변경하기도 힘듬
- 느슨한 결합
  - 결합도가 낮은 구조
  - 코드 변경이 쉬워짐

## 결합도와 책무

스프트웨어 설계에서 **책무**란 '어떤 관심사를 정상적으로 작동하게 제어해야 하는 책임'입니다.
책무를 고려하지 않고 설계를 하면 어떻게 되는지 살펴보겠습니다.

아래는 일반 할인 정책 코드입니다.

```java
class DiscountManager {
    // ...
    boolean add(Product product, ProductDiscount productDiscount) {
        // ...
    }

    static int getDiscountPrice(int price) {
        int discountPrice = price - 3000;
        // ...
        return discountPrice;
    }

    // ...
}

class Product {
    // ...
}

class ProductDiscount {
    // ...
}
```

여름 할인 정책이 추가되어 다음과 같이 코드를 작성했다고 합시다.

```java
class SummerDiscountManager {
    DiscountManager discountManager;

    boolean add(Product product) {
        // ...

        int tmp;
        if (product.canDiscount) {
            tmp = discountManager.totalPrice
                    + DiscountManager.getDiscountPrice(product.price);
        } else {
            tmp = discountManager.totalPrice + product.price;
        }
        // ...
    }
}

class Product {
    // ...
}
```

이 때 `SummerDiscountManager.add` 메서드는 `DiscountManager.getDiscountPrice` 메서드를 통해 할인 가격을 적용하고 있습니다.
이렇게 하면, **결합도가 높아** 일반 할인 서비스의 가격이 바뀌었을 때 여름 할인 서비스의 가격도 바뀌게 됩니다.
또한, `DiscountManager`가 상품 정보 확인 말고도 너무 많은 일을 하고 있습니다. 즉, **로직의 위치에 일관성이 없습니다.**
이런 클래스 설계가 바로 **책무를 고려하지 않은 설계**입니다.

이 문제를 막기 위해 중요한 것이 단일 책임 원칙입니다.
**단일 책임 원칙**은 '클래스가 담당하는 책임은 하나로 제한해야 한다'는 설계 원칙입니다.

또한, 책무를 생각하지 않고 로직의 중복을 제거하면 안됩니다.
이와 관련하여 **DRY 원칙(Don't Repeat Yourself)**이라는 것이 있습니다.
DRY 원칙은 각각의 개념 단위 내에서 반복을 하지 말라는 의미입니다.
즉, **같은 로직, 비슷한 로직이라도 개념이 다르면 중복을 허용해야 한다**는 의미입니다.

## 다양한 강한 결합 사례와 대처 방법

### 상속과 관련된 강한 결합

**상속은 주의해서 다루지 않으면, 곧바로 강한 결합 구조를 유발**하는 위험한 문법입니다.

상속 관계에서 서브 클래스는 슈퍼 클래스에 굉장히 크게 의존합니다.
그로 인해 슈퍼 클래스의 변경이 서브 클래스에 예상치 못한 문제를 일으킬 수 있습니다.

```java
class SubClass extends SuperClass {
    @Override
    int method() {
        return super.method() + 10;
    }
}
```

슈퍼 클래스 의존으로 인한 강한 결합을 피하려면, **상속보다 컴포지션을 사용**하는 것이 좋습니다.

```java
class SubClass {
    private final SupperClass supperClass;

    int method() {
        return supperClass.method() + 10;
    }
}
```

### 인스턴스 변수별로 클래스 분할이 가능한 로직

책임이 다른 메서드가 한 클래스 안에 정의되어 있으면 여러 문제가 발생할 수 있습니다.
이러한 문제를 막기 위해 '각 메서드가 어떤 인스턴스 변수를 활용하고 있는가'에 대한 파악이 필요합니다.
이를 위해 의존 관계 그림인 **영향 스케치**를 그리는 방법도 있습니다.

### 특별한 이유 없이 public 사용하지 않기

특별한 이유 없이 `public`을 관계를 맺지 않았으면 하는 클래스끼리 결합되어 영향 범위가 확대됩니다.
결과적으로 유지 보수가 어려운 강한 결합 구조가 되어버립니다.
강한 결합을 피하려면, **접근 수식자로 가시성을 적절하게 제어**해야 합니다.

| 접근 수식자    | 설명                                    |
|:----------|:--------------------------------------|
| public    | 모든 클래스에서 접근 가능                        |
| protected | 같은 클래스와 서브 클래스에서 접근 가능                |
| 없음        | 같은 패키지에서만 접근 가능, package private라고 부름 |
| private   | 같은 클래스에서만 접근 가능                       |

### private 메서드가 너무 많다는 것은 책임이 너무 많다는 것

private 메서드가 너무 많이 쓰인 클래스는 하나가 아닌 너무 많은 책임을 갖고 있을 가능성이 높습니다. 
책임이 다른 메서드는 다른 클래스로 분리하는 것이 좋습니다.

### 높은 응집도를 오해해서 생기는 강한 결합

응집도가 높다는 개념을 염두에 두고 관련이 깊다고 생각되는 로직을 한 곳에 모으려고 했지만,
결과적으로 강한 결합 구조를 만드는 상황은 매우 자주 일어납니다.
각각의 개념을 분리해야 느슨한 결합 구조로 만들 수 있으며, 
이를 '결합이 느슨하고 응집도가 높은 설계'라고 한 덩어리로 묶어 이야기 하는 경우가 많습니다.
그렇지만 강한 결합이 발생하지 않도록 하기 위해 각각의 개념을 각각의 클래스에 잘 분할해서 값 객체로 설계하는 것이 좋습니다.

### 스마트 UI

화면 표시와 직접적인 관련이 없는 책무가 구현되어 있는 클래스를 스마트 UI라고 부릅니다.
스마트 UI는 화면 표시에 관한 책무와 그렇지 않은 책무가 강하게 결합되어 있기 때문에,
책무에 대해 확인하고 서로 다른 클래스로 분할하는 것이 좋습니다.

### 거대 데이터 클래스, 트랜잭션 스크립트 패턴, 갓 클래스

거대 데이터 클래스는 수많은 인스턴스 변수와 다양한 데이터를 가지며, 수많은 유스케이스에서 사용됩니다.
결국 전역 변수와 같은 성질을 띠게 됩니다.

트랜잭션 스크립트 패턴은 메서드 내부에 일련의 처리가 하나하나 길게 작성되어 있는 구조입니다.
데이터를 보유하고 있는 클래스(데이터 클래스)와 데이터를 처리하는 클래스를 나누어 구현할 때 자주 발생합니다.
이를 남용하면 메서드 하나가 길게는 수백 줄의 거대한 로직을 갖게 됩니다.

갓 클래스는 트랜잭션 스크립트 패턴에서 한 단계 더 나아간 것으로,
하나의 클래스 내부에 수천에서 수만 줄의 로직을 담고 있으며 수많은 책임을 담당하는 로직이 난잡하게 섞여 있는 클래스입니다.

거대 데이터 클래스, 트랜잭션 스크립트 패턴, 갓 클래스와 같은 강한 결합 클래스에 대처하는 방법은 모두 같습니다.
객체 지향 설계와 단일 책임 원칙에 따라 설계하는 것입니다.
거대한 강한 결합 클래스는 책임별로 클래스를 분할해야 합니다.



