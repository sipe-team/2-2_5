# 8장 강한 결합 : 복잡하게 얽ㅕ서 풀 수 없는 구조

- 결합도 : 모듈 사이의 이존도를 나타내는 지표
- 강한 결합 : 어떤 클래스가 다른 클래스에 많이 의존하고 있는 구조
  - 강한 결합 코드의 경우는 이해하기도 힘들고 변경하기도 힘들다.
- 느슨한 결합 : 결합도가 낮은 코드 구조

## 8.1 결합도와 책무

- 책무를 생각하지 않는 경우 예상치 못한 많은 버그가 발생 할 수 있으며, 새로운 기능을 추가할 때 기존에 사용하던 기능에 영향이 있을 수 있다.
- 어떤 클래스는 처리해야 할 작업이 집중 되어 있는 반면, 어떤 클래스는 특별히 하는 일이 없을 수 있다.
  - **이런 클래스 설계의 경우를 책무를 고려하지 않는 설계라고 할 수 있다.**

### 8.1.3 단일 책임 원칙

- 단일 책임 원칙 : 클래스가 담당하는 책임은 하나로 제한해야 한다.

### 8.1.6 DRY 원칙의 잘못된 적용

> DRY원칙
>
> - 코드 중복을 피하고, 재사용성을 높이는 데 중요한 원칙

- DRY원칙을 소개한 <<실용주의 프로그래머>> 책에 의하면 해당 원칙을 다음과 같이 설명한다.

> 모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다.

- 여기서 의미하는 지식은 세분화된 정도, 기술 레이어 등 다양한 관점으로 생각할 수 있으며 그 중 하나는 소ㅗ프트웨어가 대사응로 하는 비즈니스 지식이다.
- 비즈니스 지식이란 소프트웨어에서 다루는 비즈니스 개념이다.
- **DRY는 각각의 개념 단위내에서 반복을 하지 말라는 의미이다.**
  - 같은 로직, 비슷한 로직이라도 개념이 다르면 중복을 허용해야한다. -> 상품의 `일반 할인`과 `이벤트 할인`은 할인이라는 중복된 개념이라고 생각할 수 있지만, 완전히 다른 개념이다.

## 8.2 다양한 강한 결합 사례와 대처 방법

### 8.2.1 상속과 관련된 강한 결합

- 상속은 주의해서 다루지 않으면, 곧바로 강한 결합 구조를 유발한다.

#### 슈퍼 클래스 의존

- 아래 코드와 같이 `PhysicalAttack` 클래스를 상속해서 메소드를 오버라이드 해서 구현하는 경우 `PhysicalAttack` 클래스의 메소드의 구현 방식이 변경되면, 해당 클래스를 상속 받아서 사용하는 모든 클래스의 메소드에도 영향이 있을 수 있다

``` java
// 물리 공격 클래스
class PhysicalAttack {
  // 단일 공격 대미지 리턴
  int singleAttackDamage() { ... }

  // 2회 공격 대미지 리턴
  int doubleAtttackDamage() { ... }
}
```

``` java
// 격투가의 물리 공격 클래스
class FighterPhysicalAttack extends PhysicalAttack{
  @Override
  int singleAttackDamage() {
    return super.singleAttackDamage() + 20;
  }

  @Override
  int doubleAtttackDamage() {
    return super.doubleAtttackDamage + 10;
  }
}
```

- 해당 클래스의 관계를 다이어 그램으로 그려본다면... 아래 처럼 나타낼 수 있다.

``` mermaid
classDiagram
  PhysicalAttack <|--FighterPhysicalAttack
  class PhysicalAttack {
   singleAttackDamage(): int
   doubleAtttackDamage(): int
  }
```

- 이처럼 슈퍼클래스 의존으로 인해 강한 결합 상태가 되면 코드를 변경할 때마다 매번 슈퍼 클래스를 사용하는 클래스들의 코드를 확인해야하는 문제가 발생한다.
- 이러한 문제를 해결하기 위해서는 상속보단 컴포지션을 사용하는 것이 좋다.
- `FighterPhysicalAttack`클래스를 상속이 아닌 컴포지션을 사용해서 변경하면 다음과 같이 구현할 수 있다.

```java
class FighterPhysicalAttack {
  private final PhysicalAttack physicalAttack;
  // 생략

  int singleAttackDamage() {
    return physicalAttack.singleAttackDamage() + 20;
  }

  int doubleAtttackDamage() {
    return physicalAttack.doubleAtttackDamage + 10;
  }
}
```

- 해당 관계를 클래스 다이어 그램으로 그린다면 다음과 같다.

``` mermaid
classDiagram
  PhysicalAttack <--FighterPhysicalAttack
  class PhysicalAttack {
   singleAttackDamage(): int
   doubleAtttackDamage(): int
  }
  class FighterPhysicalAttack {
    singleAttackDamage(): int
   doubleAtttackDamage(): int
  }
```

#### 상속을 사용하는 나쁜 일반화

- 상속을 사용하면 서브 클래스가 슈퍼 클래스의 로직을 그대로 사용하게 되므로, 슈퍼 클래스가 공통 로직을 두는 장소로 사용된다.
- 상속으로 무리하게 일반화 하려고하면 강한 결합이 발생하기 쉽다.
- 상속은 다른 동작을 구현하기 위해 사용하는 것이다.
- 상속은 전략 패턴 등으로 조건 분기를 줄일 떄 활용 할 수 있다.
- 상속은 반드시 단일 책임 원칙을 두고 구현하도록 해야한다.

### 8.2.3 특별한 이유 없이 public 사용하지 않기

- public와 private 같은 접근 수식자를 붙이면, 클래스와 메소드의 가시성을 제어할 수 있다.
- 하지만 특별한 이유 없이 public을 붙이면 강한 결합 구조가 되어버린다.
- public은 관계를 맺지 않았으면 하는 클래스끼리도 결합되어, 영향 범위가 확대되며, 유지보수가 어려운 강한 경합 구조가 된다.
- 강한 결합을 피하려면 접근 수식자로 가시성을 적절하게 제어해야한다.
- 클래스는 기본적으로 package private으로 만들고, 패키지 외부에 공개할 필요가 있는 클래스에 한해서만 public으로 선언해야한다.

### 8.2.4 pivate 메소드가 너무 많다는 것은 책임이 너무 많다는 것

- private 메소드가 너무 많이 쓰인 클래스는 하나가 아닌 너무 많은 책임을 갖고 있을 가능성이 높아서 private 메소드로 구현되고 있는 것이다.
책임이 다른 메소드는 다른 클래스로 분리하는 것이 좋다.

### 8.2.5 높은 응집도를 오해해서 생기는 강한 결합

- 응집도가 높다는 개념을 염두에 두고 관련이 깊다고 생각되는 로직을 한곳에 모으려고 했지만, 결과적으로 강한 결합 구조를 만드는 상황은 매우 자주 일어난다.

### 8.2.6 스마트 UI

- 화면 표시를 담당하는 클래스 중에서 화면 표시와 직접적인 관련이 없는 책무가 구현되어 있는 클래스를 스마트 UI라고 한다.
- 스마트 UI는 화면 표시에 관한 책무와 그렇지 않은 책무가 강하게 결합되어 있기 떄문에, 변경하기 아주 힘들며, 서로 다른 클래스로 분활하는 것이 좋다.

### 8.2.7 거대 데이터 클래스

- 거대 데이터 클래스는 수많은 인스턴스 변수를 가진다.

``` java
public class Order {
  public int orderId;
  public int customerId;
  public List<Prooduct> products;
  public LocalDateTime orderTime;
  ... 
}
```

- 거대 클래스는 작은 데이터 클래스보다 훨씬 더 많은 악마를 불러온다.
- 거대 클래스는 다양한 데이터를 가지므로, 수많은 유스케이스에서 사용된다.

### 8.2.8 트랜잭션 스크립트 패턴

- 메소드 내부에 일련의 처리가 하나하나 길게 작성되어 있는 구조를 트랜잭션 스크립트 패턴이라고 한다.

### 8.2.9 갓 클래스

- 갓 클래스는 하나의 클래스 내부에 수천에서 수만 줄의 로직을 담고 있으며, 수많은 책일을 담당하는 로직이 섞여 있는 클래스이다.
- 갓 클래스는 개발자의 시간을 빼앗고, 피폐하게 만드는 무서운 친구이다.
- 갓 클래스는 어떤 로직과 관련이 있는지 파악하기 힘들며, 기능을 수정 할 때 영향 범위를 파악하기 위해서 수많은 코드를 체크 해야한다.

### 8.2.10 강한 결합 클래스 대처 방법

- 거대 데이터 클래스, 트랜잭션 스크립트 패턴, 갓 클래스처럼 강한 결합 클래스에 대처하는 방법은 객체 지향 설계와 단일 책임 원칙에 따라 제대로 설계를 하는 것이다.
- 거대한 강한 결합 클래스는 책임별로 클래스를 분리해야한다.
